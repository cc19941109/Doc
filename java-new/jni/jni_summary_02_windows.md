# JNI 总结 02 Windows 纯命令行调用 DLL

## 目录

我的学习原则是先学会怎么用, 再问为什么? 

1. 调用 `HelloWorld.dll`
2. 为什么能调用 ?

## 依赖

### 查看命令是否可用

1. `g++ -v`  如果不可用, 请去搜索 `MingW`, 安装对应 `gcc`版本
2. `java -version` 如果不可用, 请安装 java 运行环境.

### 版本信息

1. `gcc version 8.1.0 (x86_64-posix-seh-rev0, Built by MinGW-W64 project)`  
2. `java version "1.8.0_191"`
3. 平台 `win 7`

## HelloWorld

### 步骤

1. 生成 `class` 文件: 
   1. 写一个含有 native 方法的 `HelloWorld.java`
   2. 用 `javac HelloWorld.java`生成 `class` 文件
2. 生成头文件: 
   1. `javah HelloWorld` -> `HelloWorld.h`
3. 生成 `dll`
   1. 写个 `HelloWorld.cpp` 输出 `HelloWorld`
   2. `g++` 编译呗 -> `HelloWorld.dll`
4. 运行!!!!!
   1.  `java HelloWorld`

那么简单!  尝试下?

### 1. 写个 `HelloWorld.java`

```java
// HelloWorld.java
public class HelloWorld {

	private static native void Hello();
	static {
		 System.loadLibrary("HelloWorld");
	}
	public static void main(String[] args){
		Hello();
	}
}
```

写完后, 用 `javac HelloWorld.java`生成 `class` 文件

这时, 目录下有 `HelloWorld.java`, `HelloWorld.class` 两个文件

## 2. 生成头文件

我们知道, 写 `C++` 文件最好有一个 `.h` 文件提供暴露的类或者接口. 在我们使用 `jni` 的时候也需要.

`javah HelloWorld` 

这时, 会生成一个 `HelloWorld.h` 文件

```c++
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloWorld */

#ifndef _Included_HelloWorld
#define _Included_HelloWorld
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloWorld
 * Method:    Hello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloWorld_Hello
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
```

没错, 你生成的文件和我的 `HelloWorld.h` 应该是一致的, 它提示我们不要去修改这个文件, 我们不去动它就是了. 

## 3. 生成 `dll`

很明显, 上面 `HelloWorld.h` 是没有实现的, 我们需要写一个  `HelloWorld.cpp`去实现头文件中的方法.

```C++
#include <iostream>
#include "HelloWorld.h"

JNIEXPORT void JNICALL Java_HelloWorld_Hello
  (JNIEnv *, jclass){
	// C++ 有自己的缓存区, java也有自己的缓存区, 由于缓存区不同所会导致, 控制台输出的内容产生顺序问题, 所以这里我们直接刷新缓存.
  	std::cout << "Hello World!\n" << std::flush;
}
```

可以看到, 我们把方法直接 copy 到`HelloWorld.cpp` 中, 然后实现了这个方法, 输出`Hello World!`

到这里, 我们检查下目录, 目录下应该有 4 个文件,  如果缺失赶紧看看前面的步骤补上哦 !

 	1. `HelloWorld.java`
 	2.  `HelloWorld.class`
 	3.  `HelloWolrd.h`
 	4. `HelloWorld.cpp`

接下来这步是我们成功的关键:

首先检查下你使用终端

如果你使用 `cmd` 进入的 windows 控制台, 请使用下面的命令

```sh
g++ -fPIC -shared -o HelloWorld.dll helloWorld.cpp -I%JAVA_HOME%/include -I%JAVA_HOME%/include/win32
```

如果你使用的是 `git bash`, 请使用下面的命令:

```sh
g++ -fPIC -shared -o HelloWorld.dll helloWorld.cpp -I$JAVA_HOME/include -I$JAVA_HOME/include/win32
```

或者你不怎么明白上面的命令, 那我告诉你, 找到 `JAVA_HOME` 环境变量, 就像下面一样输入进去

```shell
## 我的 JAVA_HOME 是: D:/environment/java
g++ -fPIC -shared -o HelloWorld.dll helloWorld.cpp -ID:/environment/java/include -ID:/environment/java/include/win32
```

好了, 顺利的话, 这时你会得到一个 `HelloWorld.dll`.

## 4. 运行!!!

​这时一个激动人心的时刻~ `[滑稽]`


```shell
java -Djava.library.path=C:/Users/Administrator/Desktop/learn_jni/win HelloWorld
```

out: 

```
Hello World!

```

讲讲为什么要用 `java.library.path`, 回顾下, 还记得我们在 `HelloWorld.java`中是怎么写的么? 

```java
System.loadLibrary("HelloWorld");
```

很显然, 我们只告诉 `jvm`一个 `HelloWorld`, 天呐!  它怎么知道去哪里这个  `HelloWorld`.  于是, 我们在 运行时, 加入了一个参数 `java.library.path`, `java`会在运行时, 从这个路径中去找 `HelloWorld.dll`. 







