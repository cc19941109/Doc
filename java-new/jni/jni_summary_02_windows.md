# JNI 总结 02 Windows 纯命令行调用 DLL

<!-- MarkdownTOC autolink="true" -->

- [目标](#%E7%9B%AE%E6%A0%87)
- [依赖](#%E4%BE%9D%E8%B5%96)
	- [查看命令是否可用](#%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8)
	- [版本信息](#%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF)
- [HelloWorld](#helloworld)
	- [步骤](#%E6%AD%A5%E9%AA%A4)
	- [1. 写个 `HelloWorld.java`](#1-%E5%86%99%E4%B8%AA-helloworldjava)
	- [2. 生成头文件](#2-%E7%94%9F%E6%88%90%E5%A4%B4%E6%96%87%E4%BB%B6)
	- [3. 生成 `dll`](#3-%E7%94%9F%E6%88%90-dll)
	- [4. 运行!!!](#4-%E8%BF%90%E8%A1%8C)
- [进阶](#%E8%BF%9B%E9%98%B6)
	- [System.load\("dll 绝对路径"\)](#systemloaddll-%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84)
	- [jni 中的方法名是怎么生成的 ?](#jni-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E7%9A%84-)
	- [不使用 `HelloWorld.h` ?](#%E4%B8%8D%E4%BD%BF%E7%94%A8-helloworldh-)
	- [g++ 编译参数](#g-%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0)
	- [关于文件路径中 `\` 和 `/`](#%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E4%B8%AD--%E5%92%8C-)

<!-- /MarkdownTOC -->


## 目标

我的学习原则是先学会怎么用, 再问为什么? 

1. 调用 `HelloWorld.dll`
2. 为什么能调用 ?

## 依赖

### 查看命令是否可用

1. `g++ -v`  如果不可用, 请去搜索 `MingW`, 安装对应 `gcc`版本
2. `java -version` 如果不可用, 请安装 java 运行环境.

### 版本信息

1. `gcc version 8.1.0 (x86_64-posix-seh-rev0, Built by MinGW-W64 project)`  
2. `java version "1.8.0_191"`
3. 平台 `win 7`

## HelloWorld

### 步骤

1. **生成 `class` 文件**: 
   1. 写一个含有 native 方法的 `HelloWorld.java`
   2. 用 `javac HelloWorld.java`生成 `class` 文件
2. **生成头文件:** 
   1. `javah HelloWorld` -> `HelloWorld.h`
3. **生成 `dll**`
   1. 写个 `HelloWorld.cpp` 输出 `HelloWorld`
   2. `g++` 编译呗 -> `HelloWorld.dll`
4. **运行!!!!!**
   1.  `java HelloWorld`

那么简单!  尝试下?

### 1. 写个 `HelloWorld.java`

```java
// HelloWorld.java
public class HelloWorld {

	private static native void Hello();
	static {
		 System.loadLibrary("HelloWorld");
	}
	public static void main(String[] args){
		Hello();
	}
}
```

写完后, 用 `javac HelloWorld.java`生成 `class` 文件

这时, 目录下有 `HelloWorld.java`, `HelloWorld.class` 两个文件

### 2. 生成头文件

我们知道, 写 `C++` 文件最好有一个 `.h` 文件提供暴露的类或者接口. 在我们使用 `jni` 的时候也需要.

`javah HelloWorld` 

这时, 会生成一个 `HelloWorld.h` 文件

```c++
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloWorld */

#ifndef _Included_HelloWorld
#define _Included_HelloWorld
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloWorld
 * Method:    Hello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloWorld_Hello
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
```

没错, 你生成的文件和我的 `HelloWorld.h` 应该是一致的, 它提示我们不要去修改这个文件, 我们不去动它就是了. 

### 3. 生成 `dll`

很明显, 上面 `HelloWorld.h` 是没有实现的, 我们需要写一个  `HelloWorld.cpp`去实现头文件中的方法.

```C++
#include <iostream>
#include "HelloWorld.h"

JNIEXPORT void JNICALL Java_HelloWorld_Hello
  (JNIEnv *, jclass){
	// C++ 有自己的缓存区, java也有自己的缓存区, 由于缓存区不同所会导致, 控制台输出的内容产生顺序问题, 所以这里我们直接刷新缓存.
  	std::cout << "Hello World!\n" << std::flush;
}
```

可以看到, 我们把方法直接 copy 到`HelloWorld.cpp` 中, 然后实现了这个方法, 输出`Hello World!`

到这里, 我们检查下目录, 目录下应该有 4 个文件,  如果缺失赶紧看看前面的步骤补上哦 !

 	1. `HelloWorld.java`
 	2.  `HelloWorld.class`
 	3.  `HelloWolrd.h`
 	4. `HelloWorld.cpp`

接下来这步是我们成功的关键:

首先检查下你使用终端

如果你使用 `cmd` 进入的 windows 控制台, 请使用下面的命令

```sh
g++ -fPIC -shared -o HelloWorld.dll helloWorld.cpp -I%JAVA_HOME%/include -I%JAVA_HOME%/include/win32
```

如果你使用的是 `git bash`, 请使用下面的命令:

```sh
g++ -fPIC -shared -o HelloWorld.dll helloWorld.cpp -I$JAVA_HOME/include -I$JAVA_HOME/include/win32
```

或者你不怎么明白上面的命令, 那我告诉你, 找到 `JAVA_HOME` 环境变量, 就像下面一样输入进去

```shell
## 我的 JAVA_HOME 是: D:/environment/java
g++ -fPIC -shared -o HelloWorld.dll helloWorld.cpp -ID:/environment/java/include -ID:/environment/java/include/win32
```

好了, 顺利的话, 这时你会得到一个 `HelloWorld.dll`.

### 4. 运行!!!

这时一个激动人心的时刻~ `[滑稽]`


```shell
java -Djava.library.path=C:/Users/Administrator/Desktop/learn_jni/win HelloWorld
```

out: 

```
Hello World!

```

讲讲为什么要用 `java.library.path`, 回顾下, 还记得我们在 `HelloWorld.java`中是怎么写的么? 

```java
System.loadLibrary("HelloWorld");
```

很显然, 我们只告诉 `jvm`一个 `HelloWorld`, 天呐!  它怎么知道去哪里这个  `HelloWorld`.  于是, 我们在 运行时, 加入了一个参数 `java.library.path`, `java`会在运行时, 从这个路径中去找 `HelloWorld.dll`. 

## 进阶

### System.load("dll 绝对路径")

可以看到上面我们使用了`System.loadLibrary()`, 相应的我们需要在 java 运行时指定 `java.library.path`. 那还有其他方法么? 我们可以直接使用绝对路径

```java
// 比如像我的dll路径是: C:\Users\Administrator\Desktop\learn_jni\win\HelloWorld.dll
// 可以像下面一样写
System.load("C:\\Users\\Administrator\\Desktop\\learn_jni\\win\\HelloWorld.dll");
```

### jni 中的方法名是怎么生成的 ?

`方法名` =  `Java_包名_类名_函数名` , 为什么要这样写呢? 这里其实是jni规定的, 为了让`JVM` 知道`.h`文件和`Java`代码中的 `native` 方法的对应关系.

我们看下面两个例子

`Java_HelloWorld_Hello` 就对应我们之前写的 `Hello` 方法

![jni_header_1](https://open-chen.oss-cn-hangzhou.aliyuncs.com/open/jni/jni_header.jpg)

![jni_header_2](https://open-chen.oss-cn-hangzhou.aliyuncs.com/open/jni/jni_header_2.png)

### 不使用 `HelloWorld.h` ?

之前有一次我使用的时候, 把`javah` 生成的 `.h`文件删掉了, 我就在想能不能不用这个文件, 于是就产生了这里不使用这个文件的方法.

我们修改下 `HelloWorld.cpp`

```c++
#include <jni.h>
#include <iostream>

extern "C" {
	JNIEXPORT void JNICALL Java_HelloWorld_Hello
	  (JNIEnv *, jclass){
	  	std::cout << "Hello World!\n" << std::flush;
	}
}
```

顺便删掉 `HelloWorld.h`

看下现在目录下的文件列表

```shell
$ ls
HelloWorld.class  HelloWorld.cpp  HelloWorld.java
```

重新编译下

```shell
java HelloWorld.java
# 这里会把原来的 HelloWorld.class 替换掉

g++ -fPIC -shared -o HelloWorld.dll helloWorld.cpp -I$JAVA_HOME/include -I$JAVA_HOME/include/win32
# 这里会新生成一个 HelloWorld.dll
```

运行!!

```shell
$ java -Djava.library.path=C:/Users/Administrator/Desktop/learn_jni/win_without_h HelloWorld
Hello World!
```

Ok, 成功了!

最后说一句, 这种方法最好不要使用, 就如生成这个文件的时候说的 `DO NOT EDIT THIS FILE`

### g++ 编译参数

`-I`：指定include包含文件的搜索目录
`-o`：输出成指定文件名，如果缺省则输出位a.out
`-shared`：指定生成动态链接库。
`-fPIC`：表示编译为位置独立的代码，用于编译共享库。目标文件需要创建成位置无关码，概念上就是在可执行程序装载它们的时候，它们可以放在可执行程序的内存里的任何地方。

参考: [gcc用法以及静态/动态链接](https://www.jianshu.com/p/31b33e5c48d7)

### 关于文件路径中 `\` 和 `/`

我实际测试下来, 在 windows 上下面的文件路径格式是可以用的

```shell
## 第一种 使用 `/`
java -Djava.library.path=C:/Users/Administrator/Desktop/learn_jni/win_without_h HelloWorld

## 第二种 使用反斜杠 `\\`
java -Djava.library.path=C:\\Users\\Administrator\\Desktop\\learn_jni\\win_without_h HelloWorld
```

但是如果你直接拷贝的win下的文件路径,例如`D:\2018\Dec\java\play-jni`可能会产生`java.lang.UnsatisfiedLinkError`, 找不到链接文件. 所以你需要把文件目录改成双反斜杠的形式.

原因就在于: String 会对使用反斜杠的字符进行转义.

