# java GC 循序渐进100 问 - 1. 基础与概念

## 前言

果然懒是写博客最大的阻碍. 

通过向别人清楚地解说一件事，来确认自己真的弄懂了这件事。[费曼学习法]

①②③等用来表示 参考的文献/网址

## 目标

## GC 入门

### 1. java 中的 GC 是什么

java 是一门可以自动管理内存的语言, 它运行在 jvm 之上, 所以根本上来说是 jvm 可以自动管理内存, jvm 通过gc (垃圾回收)来进行内存控制. 

### 2. 对象在什么时候可以被回收

不再使用的对象②. 一般一个对象不再被引用(可能有循环引用问题->1.3)，就代表该对象可以被回收

### 3. 如何判断对象是否可被回收?

一般判断一个对象是否可以被回收有两种方法 

1. **引用计数法**
2. **可达性分析算法**

#### 3.1 引用计数法是什么? 有什么缺点?

很难解决循环引用的问题

#### 3.2 简述可达性分析算法

可达性分析算法通过一组 GC ROOTS (一组活跃的引用①) 作为起点 , 从这些节点向下搜索,  **标记**所有与之关联的对象 . 标记完成之后, 没有被标记的对象就称之为 **不可用对象**(垃圾回收的目标) 

可达性分析算法可以解决 循环引用的问题

#### 3.3 不安全的可达性分析, 如误报/漏报, 会造成哪些问题?

在多线程环境下，其他线程可能会更新已经访问过的对象中的引用 ④

- 误报, 损失一部分垃圾回收的对象
- 漏报, 即忘记标记了, 在标记时, 有其他线程new了新的对象, 最后回收时, jvm认为这个对象没有被标记, 于是回收了这个实际存活的对象

#### 3.4 如何"安全"地进行可达性分析?

1. 找到所有 GC ROOTS
2. 标记时 **Stop the world**, **停止**其他**非垃圾回收线程**的工作

#### 3.5 如何找到所有的 GC Roots (3.2 延伸)

GC roots 这组引用是tracing GC ①②的起点。要实现语义正确的tracing GC，就必须要能完整枚举出所有的GC roots，否则就可能会漏扫描应该存活的对象，导致GC错误回收了这些被漏扫的活对象. 

在java语言中, GC roots 这组**引用**可能包括 ①③

- 所有Java线程当前活跃的**栈帧**里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。
- VM中**静态数据结构**里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。
- **JNI handles**，包括global handles和local handles
- （看情况）所有当前被加载的**Java类**
- （看情况）Java类的引用类型静态变量
- （看情况）Java类的运行时**常量池**里的引用类型常量（String或Class类型）
- （看情况）String常量池（StringTable）里的引用

### 4. 如何进行  STOP THE WORLD

- Java 虚拟机中的 Stop-the-world 是通过安全点（safepoint）机制来实现的
- jvm 收到 stw 请求后, 它会等待所有线程到达 safepoint, 才允许 stw 的线程独占工作
- 安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java 虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。






## 参考

- ① R大回答为什么gc要分代, 包含 GC ROOTS 相关
  - https://www.zhihu.com/question/53613423/answer/135743258
- ② 语法垃圾与语义垃圾
  - 有时在[语法垃圾](https://en.wikipedia.org/wiki/Syntactic_garbage)（程序可能无法到达的那些对象）和[语义垃圾](https://en.wikipedia.org/wiki/Semantic_garbage)（程序实际上将不再使用的那些对象）之间进行区分 garbage_collection
  -  https://en.wikipedia.org/wiki/Tracing_garbage_collection
- ③ 深入理解 JVM 3.2.2 可达性分析算法 P64
- ④ 极客时间 深入拆解 java 虚拟机 第11讲
  - https://time.geekbang.org/column/article/13091
- 

