# Synchronization and the Java Memory Model

## 原文

http://gee.cs.oswego.edu/dl/cpj/jmm.html

## 翻译总结

```java
final class SetCheck {
  private int  a = 0;
  private long b = 0;

  void set() {
    a =  1;
    b = -1;
  }

  boolean check() {
    return ((b ==  0) ||
            (b == -1 && a == 1)); 
  }
}
```

在纯粹的顺序执行语言中, `check` 方法永远不会返回 `false`. 但是编译器，运行时系统和硬件可能不会以你期望的方式执行这段代码.

- 编译器可能会重新排列指令, 所以 b 可能会比 a 先分配
- 处理器可能会重新排列机器指令, 甚至同时执行它们
- 内存系统可能会重新排列写入请求提交到内存单元的顺序, 这些写操作可能和其他内存操作重叠
- 编译器, 处理器, 内存可能会联合起来影响到语句在机器层面的执行
- 编译器，处理器和/或存储系统可能会导致表示变量的存储单元直到调用后续检查（如果有）之后的某个时间才更新，并继续在某个地方(比如CPU寄存器)保留这个值

在顺序语言中，只要程序执行遵循串行语义，这一切都无关紧要。顺序程序不能依赖简单代码块中语句的内部处理细节，因此可以自由地以所有这些方式进行操作。这为编译器和机器提供了基本的灵活性。在过去十年中，利用此类机会（通过流水线式超标量CPU，多级缓存，负载/存储平衡，过程间寄存器分配等）可极大地提高计算速度。这些操作的as-if-serial属性使顺序程序员不必知道它们是否发生或如何发生。




