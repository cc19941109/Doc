# Mysql 事务隔离

## 概述

### 知识点

1. 什么是事务? ACID 分别指什么?
2. 事务隔离级别有哪些?


## 事务

所谓的事务就是一组原子性的SQL语句.
事务内的语句, 要么全部执行成功, 要么全部执行失败.

### 如何开始事务

```sql
begin;
# 或者 start transaction;

# other sql...
commit;
# 或者 rollback
```

### ACID

ACID 即一个事务所具有的四个特点

1. atomicity 一个事务即一个不可分割的最小工作单元
2. consistency  数据库总是从一个一致性状态转换到另一个一致性状态
3. Isolation  一个事务在最终提交前, 对其他事务是不可见的
4. Durability 一旦事务提交, 则其做的修改就永久保存到数据库中了

### 事务隔离

1. 读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。 
   - 脏读, 读了别人未提交的数据
2. 读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。
   - 不可重复读, 同一次事务中, 两次查询的结果不一致
3. 可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。
   - 可能产生幻读, 但在 mysql 中由于MVCC的实现, 只有当前读的情况下会产生幻读
4. 串行：我的事务尚未提交，别人就别想改数据

#### 如何配置事务隔离级别

通过 `transaction_isolation` 配置

#### 事务隔离的实现

每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。

####  autocommit

`autocommit=1` 即显式启动事务语句，begin或者start transaction,提交commit，回滚rollback；

`set autocommit=0`，该命令会把这个线程的自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行commit或rollback或断开连接。

## MVCC

### 在事务中混合使用存储引擎

mysql 的 server 层是不管理事务的, 事务都是由下层的存储引擎实现的, 所以在同一个事务中, 使用多种存储引擎是不可靠的

当混合使用了 `innnodb`(支持事务) 和 `MyISAM`(不支持事务)的表,  那么在 `MyISAM`的表上的变更不能被回滚, 这会导致数据库处于不一致的状态.

### 视图可见性

1. 版本未提交，不可见；
2. 版本已提交，但是是在视图创建后提交的，不可见；
3. 版本已提交，而且是在视图创建前提交的，可见。

### 事务可重复读是如何实现的?

在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图

### 读提交是如何实现的?

在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。



## 其他

### undo log

事务中, 语句更新会生成 undo log（回滚日志）

### start transaction with consistent snapshot

它的含义是： 执行 start transaction 同时建立本事务一致性读的 snapshot . 而不是等到执行第一条语句时，才开始事务，并且建立一致性读的 snapshot .

https://www.cnblogs.com/digdeep/p/4947694.html



有个问题, 一个事务提交了, 但是另一个事务回滚了, 那么修改的值会怎么样?

INNODB保证: 事务启动以前所有还没提交的事务，它都不可见。






## 疑问

1. `information_schema.innodb_trx` 这张表是做什么的 ?
   - `select * from information_schema.innodb_trx ;`
2. 为什么不建议使用长事务
   - 长事务意味着系统里面会存在很老的事务视图, 在这个事务未提交之前, 数据库里面它可能用到的回滚记录都必须保留, 这会导致大量的占用存储空间
   - 在开发过程中，尽可能的减小事务范围，少用长事务，如果无法避免，保证逻辑日志空间足够用，并且支持动态日志空间增长。监控`Innodb_trx`表，发现长事务报警。
3. MVCC 是什么, 怎么实现的?
4. `read-view` 读视图是什么 ? 
5. 回滚日志什么时候清除 ?
