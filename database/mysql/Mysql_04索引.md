# Mysql 索引

## 概述

为了提高数据查询的效率

索引时在存储引擎层实现的



### 联合索引使用上的一些注意

### 覆盖索引

1. 如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据

2. 数据量很大的时候，二级索引比主键索引更快, 只有在覆盖索引时才会成立, 非覆盖索引还是要回表查询。

总的来说, 覆盖索引的作用限定在返回字段在普通索引中已经存在, 就不需要再回表查询了

#### 最左前缀原则

B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录

联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符

所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独的 a 索引了, 但如果查询条件中只有 b 的语句, 还是要单独加一个 b 索引

#### 查询时如何用到联合索引

根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以 `name=‘张三’ `不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。

#### 索引下推 ICP

`like 'hello%’and age >10 ` 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度

#### 

### 关于索引使用的一些经验

给表创建索引时，应该创建哪些索引，每个索引应该包含哪些字段，字段的顺序怎么排列，这个问题没有标准答案，需要根据具体的业务来做权衡。不过有些思路还是可供参考的：

1. 既然是一个权衡问题，没有办法保证所有的查询都高效，那就要优先保证高频的查询高效，较低频次的查询也尽可能的使用到尽可能长的最左前缀索引。可以借助 `pt-query-digest` 来采样统计业务查询语句的访问频度，可能需要迭代几次才能确定联合索引的最终字段及其排序。
2. 业务是在演进的，所以索引也是要随着业务演进的，并不是索引建好了就万事大吉了，业务发生变化时，我们需要重新审视当初建的索引是不是还依然高效，依然能满足业务需求。
3. 业内流传的有一些mysql 军规，其实这些并不是真正的军规，只是典型场景下的最佳实践。真正的军规其实就一条：高效的效满足业务需求.

-- 来自 `melon` 的评论

### 其他

#### `limit ` 操作是在 server 层做还是在 存储引擎层做

server 层做的

#### `Multi-Range Read (MRR) ` 是什么?

#### N叉树 和 数据页什么关系? 数据页是什么? 

树高其实取决于叶子树（数据行数）和“N叉树”的N。 而N是由页大小和索引大小决定的。

#### ICP 是什么?

Index Condition Pushdown 即索引下推

## 疑问

1. 请问没有主键的表, 是怎么查询的?

   -  作者回复: 没有主键的表，innodb会给默认创建一个Rowid做主键
2. 访问磁盘和内存索引涉及磁盘(sata，ssd，nvm)读写性能，以及内存读写性能，可否给一些数值方便直观认识?

   - T his group of numbers is from a presentation Jeff Dean gave at a Engineering All-Hands Meeting at Google.

   - L1 cache reference 0.5 ns
     Branch mispredict 5 ns
     L2 cache reference 7 ns
     Mutex lock/unlock 100 ns
     Main memory reference 100 ns
     Compress 1K bytes with Zippy 10,000 ns
     Send 2K bytes over 1 Gbps network 20,000 ns
     Read 1 MB sequentially from memory 250,000 ns
     Round trip within same datacenter 500,000 ns
     Disk seek 10,000,000 ns
     Read 1 MB sequentially from network 10,000,000 ns
     Read 1 MB sequentially from disk 30,000,000 ns
     Send packet CA->Netherlands->CA 150,000,000 ns
3. 一个innoDB引擎的表，数据量非常大，根据二级索引搜索会比主键搜索快，. 为什么二级索引要快 ?
   - 覆盖索引
4. `B+树` 是怎么实现的 ?
   - N 叉树
   - 非叶子节点都只存储键值信息
   - 数据记录都存放在叶子节点中
   - 所有叶子节点之间都有一个链指针
5. 为什么使用 `B+树`
   - 相对于 哈希表、有序数组和二叉搜索树 
6. 为什么要使用 `N叉树` 
7. “N叉树”的N值在MySQL中是可以被人工调整的么？
8. `lsm 树` 是什么
9. `myisam`引擎支持事务
   - 只能通过 `lock table` 实现串行化隔离















