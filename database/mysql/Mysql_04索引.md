# Mysql 索引

## 概述

1. 索引的出现是为了提高数据查询的效率
2. 索引在存储引擎层实现的

### 目录

1. 如何实现索引
  - [如何选择索引的数据结构](#如何选择索引的数据结构)
  - [为什么使用`N叉树`](N叉树)
2. `Innodb` 索引
   - [索引的利弊](索引有什么好处和坏处)
   - [为什么使用 `B+` 树](为什么使用 `B+` 树)
   - 

## 如何实现数据库索引

### 如何选择索引的数据结构

#### 哈希表

使用哈希表做索引, 则查询的效率在 O(n) , 但因为不是有序的, 所以哈希索引做**区间查询**的速度会很慢

哈希表适合作为 NOSQL 的引擎

#### 有序数组

数组在等值查询和范围查询中的性能都十分优秀, 但当需要添加记录时, 则需要移动很多原有的数据, 时间复杂度会很高

#### 二叉搜索树

 在递增的元素插入时, 整棵树的查询性能会变的很差, 还有一点是, 当有一个100万节点的二叉树时, 树高20, 一次查询需要访问20个数据, 当这些数据都随机的分布在磁盘中时, 寻址的时间会很长, 非常影响性能. 

#### N叉树

为了更好的减少读磁盘的次数, 我们可以使用 N叉树. 

这里有个问题, 为什么我们要使用N叉树而不是二叉树? N叉树的性能难道比二叉树还好么?

> 主要原因在于从 CPU -> 主存 -> 磁盘 , 速度依次递减
>
> 我们可以看下下面的数据: 
>
> >  Figure 3 in the middle of this article, [The Pathologies of Big Data](http://queue.acm.org/detail.cfm?id=1563874), says that memory is only about 6 times faster when you're doing sequential access (350 Mvalues/sec for memory compared with 58 Mvalues/sec for disk); but it's about 100,000 times faster when you're doing random access.
> >
> > 在主存中读的速度大概是磁盘顺序读的 6 倍, 大概是 磁盘随机读取的 100000倍
> >
> > https://stackoverflow.com/questions/1371400/how-much-faster-is-the-memory-usually-than-the-disk
>
> 简单的说, 访问 RAM 的速度是纳秒级别的(10^-9 秒), 访问磁盘是 毫秒级别的(10^-3秒) 
>
> 磁盘随机读取慢, 主要是磁盘要旋转, 寻址比较慢, 而顺序读取只需要很少的旋转时间
>
> 而数据库中的数据是存放在磁盘中的, 我们需要先解决主要矛盾, 即尽可能的减少磁盘读取的次数, 比如当我们使用 `"1000 叉树"` 时, 即使数据有10亿条, 我们也只需要访问3次磁盘

## `InnoDB` 的索引

`innodb` 中使用 `B+tree` 作为索引, 每一个索引在`innodb` 中对应一颗 `B+ tree`

### 索引有什么好处和坏处

使用索引可以加快查询速度. 

但尽管为查询中使用的每个可能列创建索引很有诱惑力，但不必要的索引会浪费空间并浪费时间让MySQL确定要使用的索引。索引还会增加插入，更新和删除的成本，因为必须更新每个索引。必须找到适当的平衡，以使用最佳索引集实现快速查询。(翻译自mysql8.0的官方文档)  

简单来讲坏处有这些:

1. 占用空间增大
2. server 层会分析如何使用索引, 可能会浪费时间做这些分析
3. 增大插入,更新,删除的成本

### 为什么使用 B+ 树

`2-3树`  -> `B tree` -> `B+ tree` 这三种树都是`N叉树`

主要原因前面已经讲过了, 主要是因为B+树更加适合磁盘读写.当然还有一些其他原因, 我这边先不展开.

### `B+ tree` 中存了什么

1. 主键索引的叶子节点存的是整行数据。
2. 非主键索引的叶子节点内容为主键的值

### 基于主键索引和普通索引的查询有什么区别?

假设有这样一张表

```sql
create table Table_1(
id int primary key, 
k int not null, 
name varchar(32),
index (k))engine=InnoDB;
```

这里 我们假设主键的索引为`index_1`, 列`k`的普通索引为 `index_2` 

1. 查询 `select * from Table_1 where id=1;`,  则我们只需要查`index_1` 就可以了
2. 查询`select * from Table_1 where k=2;`, 则我们需要先查 `index_2`, 找到主键的值, 然后根据主键的值, 再查 `index_1` . 我们称这个过程为`回表`

### 为什么建议使用递增主键, 而不是自定义主键

1. 递增主键使用的都是数字, 使用数字作为主键的好处是主键的长度比较短. 而我们知道普通索引里存的都是主键, 主键的长度小一点, 普通索引的占用空间也小一点
2. 由于采用 `B+ tree` 实现, 有序的插入可以减少挪动其他记录, 也不会出发叶子节点分裂?(todo why?) B+树的插入可能会引起数据页的分裂，删除可能会引起数据页的合并，二者都是比较重的IO消耗，所以比较好的方式是顺序插入数据

但也有例外的情况, 递增主键也不一定最适合你的业务, 有时用一个业务逻辑的主键也是可以的. 所以我只能说一般情况下推荐使用递增主键

### 为什么要重建索引? 如何重建索引

重建普通索引, 可以压缩索引所占用的空间, 使得空间利用率更高, 不过要注意在业务低谷期操作, 以免影响业务.

但如果是要重建主键索引, 可以使用这句 `alter table Table_1 engine=InnoDB;`(todo why?)

重建主键索引, 会修改普通索引对应的主键索引, 性能消耗很大. 或者可以先删普通索引, 再删主键索引, 再建主键索引, 最后建普通索引

### N叉树的N值在mysql中可以被人工调整么?

5.6以后可以通过page大小来间接控制(todo why?)

### 没有主键的表有索引么?

没有主键的表，`innodb`会给默认创建一个Rowid做主键

## 索引优化

### 减少回表

回到主键索引树搜索的过程, 我们称为回表

#### 覆盖索引

如在普通索引查询主键

#### 扫描行数

在**存储引擎层**, 对某个范围进行查找时, 可能会多扫描一行

#### 联合索引

例如:

```sql
CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB

```

维护索引需要成本, 权衡查询与索引成本.

#### 二级索引搜索有时比主键搜索快,为什么?



#### 联合索引在B+树中的存储方式



### 联合索引使用上的一些注意

### 覆盖索引

1. 如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据

2. 数据量很大的时候，二级索引比主键索引更快, 只有在覆盖索引时才会成立, 非覆盖索引还是要回表查询。

总的来说, 覆盖索引的作用限定在返回字段在普通索引中已经存在, 就不需要再回表查询了

#### 最左前缀原则

B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录

联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符

所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独的 a 索引了, 但如果查询条件中只有 b 的语句, 还是要单独加一个 b 索引

#### 查询时如何用到联合索引

根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以 `name=‘张三’ `不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。

#### 索引下推 ICP

`like 'hello%’and age >10 ` 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度

#### 

### 关于索引使用的一些经验

给表创建索引时，应该创建哪些索引，每个索引应该包含哪些字段，字段的顺序怎么排列，这个问题没有标准答案，需要根据具体的业务来做权衡。不过有些思路还是可供参考的：

1. 既然是一个权衡问题，没有办法保证所有的查询都高效，那就要优先保证高频的查询高效，较低频次的查询也尽可能的使用到尽可能长的最左前缀索引。可以借助 `pt-query-digest` 来采样统计业务查询语句的访问频度，可能需要迭代几次才能确定联合索引的最终字段及其排序。
2. 业务是在演进的，所以索引也是要随着业务演进的，并不是索引建好了就万事大吉了，业务发生变化时，我们需要重新审视当初建的索引是不是还依然高效，依然能满足业务需求。
3. 业内流传的有一些mysql 军规，其实这些并不是真正的军规，只是典型场景下的最佳实践。真正的军规其实就一条：高效的效满足业务需求.

-- 来自 `melon` 的评论

### 其他

#### `limit ` 操作是在 server 层做还是在 存储引擎层做

server 层做的

#### `Multi-Range Read (MRR) ` 是什么?

#### N叉树 和 数据页什么关系? 数据页是什么? 

树高其实取决于叶子树（数据行数）和“N叉树”的N。 而N是由页大小和索引大小决定的。

#### ICP 是什么?

Index Condition Pushdown 即索引下推

## 疑问

1. 请问没有主键的表, 是怎么查询的?
   - 没有主键的表，innodb会给默认创建一个Rowid做主键

2. 访问磁盘和内存索引涉及磁盘(sata，ssd，nvm)读写性能，以及内存读写性能，可否给一些数值方便直观认识?

   - T his group of numbers is from a presentation Jeff Dean gave at a Engineering All-Hands Meeting at Google.

   - L1 cache reference 0.5 ns
     Branch mispredict 5 ns
     L2 cache reference 7 ns
     Mutex lock/unlock 100 ns
     Main memory reference 100 ns
     Compress 1K bytes with Zippy 10,000 ns
     Send 2K bytes over 1 Gbps network 20,000 ns
     Read 1 MB sequentially from memory 250,000 ns
     Round trip within same datacenter 500,000 ns
     Disk seek 10,000,000 ns
     Read 1 MB sequentially from network 10,000,000 ns
     Read 1 MB sequentially from disk 30,000,000 ns
     Send packet CA->Netherlands->CA 150,000,000 ns
3. 一个innoDB引擎的表，数据量非常大，根据二级索引搜索会比主键搜索快，. 为什么二级索引要快 ?

   - 覆盖索引
4. `B+树` 是怎么实现的 ?
   - N 叉树
   - 非叶子节点都只存储键值信息
   - 数据记录都存放在叶子节点中
   - 所有叶子节点之间都有一个链指针
5. 为什么使用 `B+树`
   - 相对于 哈希表、有序数组和二叉搜索树 
6. 为什么要使用 `N叉树` 
7. “N叉树”的N值在MySQL中是可以被人工调整的么？
8. `lsm 树` 是什么
9. `myisam`引擎支持事务
   - 只能通过 `lock table` 实现串行化隔离

10. 一个innoDB引擎的表，数据量非常大，根据二级索引搜索会比主键搜索快，文章阐述的原因是主键索引和数据行在一起，非常大搜索慢，但通过普通索引找到主键ID后，同样要跑一边主键索引 . 为什么二级索引要快 ?
11. `2-3查找树` 是什么? 优缺点是什么?
    - 优: `2-3查找树` 即使在最坏的情况下, 也拥有较好的性能, 任何查找/插入的成本都不会超过对数级别
    - 劣: 需要维护两种不同类型的节点, 实现起来很复杂, 且它们所产生的额外开销可能会使算法比标注的二叉查找树更慢
12. 10 个升序的数字插入 `2-3树` ,则 树的高度是多少 ?
    - 树高为 2
13. `B-tree` 是什么 ?
14. `B+树` 是怎么实现的 ?
15. 为什么使用 `B+树`
16. `B-tree` 和 `B+tree` 有什么关联和区别 ?

    - http://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html
17. 为什么要使用 `N叉树` 
18. “N叉树”的N值在MySQL中是可以被人工调整的么？
19. `lsm 树` 是什么

















