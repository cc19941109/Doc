# 你不知道的JS - 作用域

## 概述

源于 你不知道的JS 上卷 https://book.douban.com/subject/26351021/ 

主要用于总结归纳

## 作用域

### `var a =2` 的编译

1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的
    集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作
    用域的集合中声明一个新的变量，并命名为 a。
2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值
    操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的
    变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量（查看 1.3
    节）。



### LHS RHS

- https://segmentfault.com/a/1190000010645079

变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值

要讲的 `LHS` 和 `RHS` 就是上面说的对变量的两种查找操作，查找的过程是由作用域（词法作用域）进行协助，在编译的第二步中执行

LHS - **赋值**操作的目标是谁 

RHS - 谁是赋值操作的源头 - **Retrieve** his source value



### 严格模式

```use strict```

严格模式在行为上有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询失败时类似的 **ReferenceError** 异常。

### 异常

**ReferenceError 同作用域判别失败相关，**而 **TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的**。



