# 了解下计算机中的 I/O

### 什么是 I/O

IO 指的是 计算机内部世界(内存) 与外部设备(内存,磁盘,显卡,声卡,网卡,键盘,鼠标...)之间的数据拷贝的过程

https://en.wikipedia.org/wiki/Input/output

### 物理内存和虚拟内存

https://blog.csdn.net/u012861978/article/details/53048077

1. 多个进程使用的可能是同一块物理空间
2. 操作系统保证, 进程之间的空间 逻辑上不能相互访问 (这里用到的就是虚拟地址)
3. 虚拟地址(实际就是虚拟内存)映射实际的物理内存, 或者存储器地址(磁盘)

虚拟地址可以让进程共享物理内存, 提高内存利用率, 还可以扩展内存的地址空间

一个进程不活动的情况下, 操作系统会将这个进程占用的物理空间,移到磁盘文件中([windows下为页面文件, 微软官方回答](https://support.microsoft.com/zh-cn/help/2160852/ram-virtual-memory-pagefile-and-memory-management-in-windows), [linux的交换分区](https://www.cnblogs.com/kerrycode/p/5246383.html)), 这是为了将宝贵的内存空间留给正在活动的程序使用. 但当这些文件频繁使用时, 说明物理内存已经不够用了, 程序运行的效率会非常低下, 这时候就要开源节流了(内存)

### 内核空间与用户空间

一台计算机通常有一定大小的内存空间, 但我们日常使用的程序并不能完全使用这些空间. 原因就在于这些空间被划分为了内核空间与用户空间. 程序只能使用 用户空间.

内核空间主要用于操作系统运行时所拥有. 为什么要这么做呢? 为了保证操作系统的稳定性(谁也不想打开个软件, 这个软件出了bug, 然后系统直接死机了吧). 另外从安全性上考虑, 访问硬件资源只能由操作系统发起(如果不是这样的话, 软件A打开占用了X1的内存空间, 软件B操作X1的内存空间, 这样就直接把软件A弄死了,这样也不行).

这里就涉及到我们这节讲的I/O了, 一般而言, I/O 对应的外部设备都需要操作系统提供支持, 在内核空间中执行. 用户程序需要访问, 必须使用操作系统提供的接口来实现(即系统调用). 举个例子, 网络传输时, 操作系统在内核空间中拿到远程主机的数据, 再从内核空间复制到用户空间,供用户程序使用. 仔细想一下, 虽然这种方式比较安全, 但是也降低了效率, 以至于后来出现了 zero-copy 的技术.

参考:

1. https://www.cnblogs.com/sparkdev/p/8410350.html
2. 深入分析 java web 技术内幕(修订版) 8.2 内核空间与用户控件 P200


### 什么是 IO 模型

IO 模型是一种输入/输出的处理形式

实际上是I/O 模型是为了解决内存和外部设备速度差异的问题

当用户线程发起 I/O 操作后，网络数据读取操作会经历两个步骤：

1. 用户线程等待内核将数据从网卡拷贝到内核空间。
2. 内核将数据从内核空间拷贝到用户空间。

各种 I/O 模型的区别就是：它们实现这两个步骤的方式是不一样的。

参考:

1. https://time.geekbang.org/column/article/100307



