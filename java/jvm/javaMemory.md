**# java内存

参见：《深入理解JAVA虚拟机》

# 第二章 java 内存区域与内存溢出异常

## 运行时数据区域

线程隔离：程序计数器(Program Counter Register)、虚拟机栈(VM Stack)、本地方法栈(Native method stack)

所有线程共享的数据区：堆(heap)、方法区(method area)

### 2.2.1 程序计数器 Program Counter Register


### 2.2.2 虚拟机栈

虚拟机栈是线程私有的，它的生命周期和线程相同。

虚拟机栈描述的是 java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧(Stack Frame，栈帧是方法运行时的基础数据结构)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

栈帧越大,栈深度越小

超过栈的深度会有, StackOverflowError

无法申请到足够内存,outofmemoryError


### 2.2.3 本地方法栈 Native method stack

简单地讲，一个Native Method就是一个java调用非java代码的接口

对于一个运行中的Java程序而言，它还可能会用到一些跟本地方法相关的数据区。当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，但不止如此，它还可以做任何它想做的事情。


### 2.2.4 堆 Heap

被所有线程共享的一块内存区域，在虚拟机启动时创建。heap一般存放对象实例，在java虚拟机规范中的描述是：**所有的对象实例以及数组都在这里分配对象**

java堆是垃圾收集器管理的主要区域。

堆可以使物理上不连续的内存空间，只要逻辑上连续就行了。

```
-Xms:初始堆大小
-Xmx:最大堆大小
```


### 2.2.5 方法区 Method Area

存放已被虚拟机加载的**类信息，常量，静态变量**，即时编译器编译后的代码。

有些人喜欢把方法区称为永生代，但此区域的部分内存仍需回收。这个区域的内存回收目标的主要对象是针对**常量池的回收 和 对类型的卸载。**


### 2.2.6 运行时常量池


runtime constant pool 是方法区的一部分

String.intern()将字符串放入运行时常量池,返回string对象的引用

### 2.2.7 直接内存


指本机的直接内存，不受java堆的限制，受本机总内存/cpu寻址空间的限制



## 2.3 HotSpot 虚拟机对象探秘


### 2.3.1 对象的创建

1. 在常量池定位到一个类的符号引用,查看这个类是否被加载过
2. 如果没有被加载过,则先执行类加载
3. 通过类检查后,执行内存分配

	- 指针碰撞,空闲列表
	- cas 算法 aba, 循环时间过长,多个共享变量
	- JVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB（Thread-local allocation buffer）。默认设定为占用Eden Space的1%。
	- 在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。

	参考:[JVM源码分析之线程局部缓存TLAB](https://www.jianshu.com/p/cd85098cca39)
	
4. 设置对象头

	- 类信息,元数据类型,哈希码, GC 分代年龄信息

5. 执行 <init>

### 2.3.2 对象的内存布局

对象在内存中存储的布局,主要分三块区域：

1. 对象头
2. 实例数据
3. 对齐填充

查看内存使用

```
-verbose:gc -Xms20M -Xmx20m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError
```

### 2.3.3 对象的访问定位

通过栈上的 reference 数据来操作堆上的具体对象, reference类型 只有一个指向对象的引用, jvm 并没有规定这个引用应该用何种方式去定位,访问堆中的对象.

一般主流的访问方式:

1. 使用句柄

	- 有一个句柄池,到存放对象的实例数据的指针 和 到对象类型数据的指针

2. 直接指针

	- 存放的就是指向对象的指针
	- hotspot使用的这种


## 2.4 实战：OutOfMemoryError

### 2.4.2 虚拟机栈和本地方法栈溢出

在Hotspot虚拟机中并不区分虚拟机栈和本地方法栈，其栈容量由-Xss设置，而本地方法栈的设置-Xoss实际上是无效的。

线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 **StackOverflowError**

虚拟机在扩展栈时无法申请到足够的内存空间，将抛出 **OutOfMemoryError**


# 垃圾收集器与内存分配策略

## 3.1 概述

Garbage Collection 

垃圾回收的部分: 堆 和 方法区


### 3.2 判断对象已死


### 3.2.1 引用计数算法

给对象添加一个引用计数器,有一个地方引用就加1,当引用失效就减1;任何时刻计数器为0的对象就是不可能再被使用

**问题:**

不能解决循环引用的问题

### 3.2.2 可达性分析算法

通过 ```GC Roots```的对象来作为起始点,从这些节点开始向下搜索,其走过的路径称为引用链(Reference chain)

只要```GC Roots```到这个对象不可达,就应该被回收

#### 可作为 GC Roots 对象

1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法去中常量引用的对象
4. 本地方法栈中 JNI(java native interface)引用的对象

### 3.2.3 再谈引用

- 强引用:存在就不会被回收
- 软引用:有用但非必须,在发生内存溢出前回收
- 弱引用:在下次垃圾回收前存活
- 虚引用:对象会在被垃圾回收前收到一个系统通知


### 3.2.4 生存还是死亡

要宣告一个对象死亡,至少要经过两次标记

1. 发现没有与 GC Roots 关联,被标记一次并且进行一次筛选

	- 此对象是否有必要执行 ```finalize()```方法,当对象没有覆盖```finalize()```方法,或者已经被调用过,则会放置在一个```F-Quene```的队列中,稍后由一个低优先度的 ```Finalizer```线程去执行.
	- 在```finalize()```方法中,对象重新关联上引用链上的任何一个对象就可以拯救自己被回收
	- 要注意的是,```finalize()```方法最多被执行一次,也就是对象最多被拯救一次

2. 如果没有在```finalize()```方法中关联上引用链上的对象, GC将对```F-Quene```的队列中的对象做第二次标记,这是就真的被回收了



### 3.2.5 回收方法区

主要回收:

1. 废弃常量
2. 无用的类

在大量使用反射,动态代理, CGLib 等bytecode 框架这类频繁自定义 classloader 的场景都需要虚拟机具备类卸载功能,以保证方法区不会溢出(hotspot 的永生代)


## 3.3 垃圾收集算法

### 3.3.1 标记-清除算法


### 3.3.2 复制算法

一般用这种算法来回收**新生代**,将内存分为 一块大的 Eden 空间,两块小的 Survivor 空间,比例一般为8:1:1

### 3.3.3 标记-整理算法

存活对象向一端移动

### 3.3.4 分代收集算法

区别对待新生代,老生代,采用最适合的算法


## 3.4 hotspot 算法实现

1. 枚举根节点,停顿
2. 安全点
3. 安全区

## 3.5 垃圾收集器




# 第12章 java 内存模型与线程

## 12.1 概述

## 12.2 硬件的效率与一致性

















**