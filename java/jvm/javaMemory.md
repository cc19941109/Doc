# java内存

参见：《深入理解JAVA虚拟机》第二章

## 运行时数据区域

线程隔离：程序计数器(Program Counter Register)、虚拟机栈(VM Stack)、本地方法栈(Native method stack)

所有线程共享的数据区：堆(heap)、方法区(method area)

### 2.2.1 程序计数器 Program Counter Register


### 2.2.2 虚拟机栈

虚拟机栈是线程私有的，它的生命周期和线程相同。

虚拟机栈描述的是 java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧(Stack Frame，栈帧是方法运行时的基础数据结构)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。



### 2.2.3 本地方法栈 Native method stack

简单地讲，一个Native Method就是一个java调用非java代码的接口

对于一个运行中的Java程序而言，它还可能会用到一些跟本地方法相关的数据区。当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，但不止如此，它还可以做任何它想做的事情。


### 2.2.4 堆 Heap

被所有线程共享的一块内存区域，在虚拟机启动时创建。heap一般存放对象实例，在java虚拟机规范中的描述是：所有的对象实例以及数组都在这里分配对象。

java堆是垃圾收集器管理的主要区域。

堆可以使物理上不连续的内存空间，只要逻辑上连续就行了。



### 2.2.5 方法区 Method Area

存放已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码。

有些人喜欢把方法区称为永生代，但此区域的部分内存仍需回收。这个区域的内存回收目标的主要对象是针对常量池的回收 和 对类型的卸载。


### 2.2.6 运行时常量池


runtime constant pool 是方法区的一部分

String.intern()将字符串放入运行时常量池,返回string对象的引用

### 2.2.7 直接内存


指本机的直接内存，不受java堆的限制，受本机总内存/cpu寻址空间的限制



## 2.3 HotSpot 虚拟机对象探秘


### 2.3.1 对象的创建


### 2.3.2 对象的内存布局



主要分三块区域：对象头、实例数据和对齐填充

查看内存使用

```
-verbose:gc -Xms20M -Xmx20m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError
```

## 2.4 实战：OutOfMemoryError

### 2.4.2 虚拟机栈和本地方法栈溢出

在Hotspot虚拟机中并不区分虚拟机栈和本地方法栈，其栈容量由-Xss设置，而本地方法栈的设置-Xoss实际上是无效的。

线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 **StackOverflowError**

虚拟机在扩展栈时无法申请到足够的内存空间，将抛出 **OutOfMemoryError**

























